// create a new attribute simply by typing *@attrib_name with
// * representing its signature
// v@ ‐ vector, i@ ‐ integer, f@ ‐ float, 3@ ‐ matrix3, p@ ‐ vector4
// 4@ ‐ matrix4, 2@ ‐ matrix2, u@ ‐ vector2, s@ ‐ string,
v@myVector = {1,2,3};
// vectors with functions/variables in them need to be created with set()
u@myVectorFunc = set(@Frame, v@P.y);
u@myVector2 = {4,5};
f@myFloat = 400.0;
i@myInteger = 727;
3@myMatrix3x3 = matrix3( ident() ); // function casting, will be explained in other node
4@myMatrix4x4 = matrix( ident() );
s@myString = "abc";

// arrays can be exported as well
v[]@myVectorArray = { {1,2,3}, {4,5,6}, {7,8,9} };
u[]@myVector2Array = { {4,5}, {6,7} };
f[]@myFloatArray = { 4.0, 2.7, 1.3};
i[]@myIntegerArray = {132, 456, 789};
// arrays containing functions/variables need to be initialized with array() function
3[]@myMatrix3x3Array = array( matrix3( ident() ), matrix3( ident() ) * 5 ); // refer to functions_casting node for the meaning of matrix3()
4[]@myMatrix4x4Array = array( matrix( ident() ), matrix( ident() ) * 9 );
s[]@myStringArray = { "abc", "def", "efg" };
========================================

  ch("flt1");             // Float
  chf("flt2");            // Float
  chi("int");             // Integer
  chv("vecparm");         // Vector 3
  chp("quat");            // Vector 4 / Quaternion
  ch3("m3");              // 3x3 Matrix
  ch4("m4");              // 4x4 Matrix
  chs("str");             // String
  chramp("r", x);         // Spline Ramp
  vector(chramp("c", x)); // RGB Ramp


()  Grouping
()  Grouping
-a  Unary negation
a^b Raise to exponent
* / % Times, divide, modulus
+ - Add, subtract
< > == != || && Less than, greater than, equals, not equals, or, and

=================time
    @Time //Float time ($T)
    @Frame //Float frame ($FF)
    @SimTime //Float simulation time ($ST), only present in DOP contexts.
    @SimFrame //Float simulation frame ($SF), only present in DOP contexts.
    @TimeInc //Float time step (1/$FPS)

========================inputs()
//Other inputs

    v@P.y = v@opinput1_P.y;
    f@y = v@opinput1_P.y;
=====================================


==================dop==========
===DOPs / Gas Field Wrangle ‐ accessing DOPs and SOPs data
// it is also possible to access DOP fields using this syntax
// we can sample "pig_mask" without setting the field "Inputs"
float pig_mask = 0;
// the following lines bellow are identical, the second and third ones are more flexible as they refer to relative path,
// it will work even if we renamed this DOP network, the first line would not work after that
// the second argument is either an int representing primitive number, or string representing primitive name
// the syntax for accessing DOP data is: op:/DOP_path:dop_object/field_name
pig_mask = volumesample("op:/obj/examples/dopnet_vex_vops_volume:volume/pig_mask", 0, v@P);
//pig_mask = volumesample("op:" + opfullpath("../") + ":volume/pig_mask", "pig_mask", v@P);
//pig_mask = volumesample("op:../" + ":volume/pig_mask", 0, v@P); // op: syntax also accepts relative paths
// we can also directly access SOP volumes using this syntax
//pig_mask = volumesample("op:../../IN_VOLUMES", 1, v@P);
f@pig_in *= 1‐pig_mask;
//fetch field from dopnet / 
/obj/sphere1/pyrodopnet:smokeobject1/density
=====================================



==========DOPs / Geometry Wrangle ‐ accessing fields
// we can also access DOP fields from Geometry Wrangle, it is explained in:
// /obj/examples/dopnet_vex_vops_volume/gasfieldwrangle_accessing_DOPs_and_SOPs_data
// all following lines will produce the same result
float mask = 0;
mask = volumesample("op:../" + ":box/pig_mask", 0, v@P);
//mask = volumesample("op:" + opfullpath("../") + ":box/pig_mask", "pig_mask", v@P);
//mask = volumesample("op:../../IN_VOLUMES", 1, v@P);
// visualize what points sampled non‐zero density in the volume
if (mask != 0) v@Cd = {1,0,0};


//import dopnet gelationship directly in object merge
../secondarySim:Relationships/constraintnetwork1/Geometry

=====================================


================Conditions
// it there is only one operation after if condition, this operation
// can be written in the same line
if (v@P.y < 0) v@Cd = {1,0,0};
// or in any other line, since VEX is not indented language,
// but this works only for one operation, else‐if block will end with the first ; symbol
else if (v@P.x < 0) 
                    v@Cd = {0,1,0};
// to execute more operations, we need to use a block of code in {} brackets
else {
    v@Cd = {0,0,1};
    v@P += v@N;
}
// it is also possible to use conditional (ternary) operator with the following syntax
// (condition) ? true : false
v@P.x *= v@P.x > 0 ? 0.5 : 1.5;
// and use of logical AND: &&, OR: || is also possible
if (v@P.y < 0 && v@P.x > 0) v@P ‐= v@N * .3;
if (v@Cd == {0,0,1} || v@Cd == {1,0,0}) v@P += v@N * .4;

//shortcut for statement
float a = condition? b: c;
=====================================


=========Loops
Check Houdini project to get the best idea of how it works.
// VEX uses common syntax for for‐loops
int valA = 2;
for (int i=0; i<11; i++) {
    valA *= 2;
}
i@valA = valA;
// for convenient iterating over elements of an array we
// can use foreach loop
int nbs[] = nearpoints(0, v@P, .5);
vector P_avg = {0};
foreach(int nb_ptnum; nbs) {
    P_avg += point(0, "P", nb_ptnum);
}
P_avg /= len(nbs);
v@P = P_avg;
// we can also stop the loop by using "break" keyword
int valB = 5;
for (int i=0; i<13; i++) {
    valB *= 5;
    if (valB > 10000000) break;
}
i@valB = valB;
// we can also use "continue" keyword to jump to another loop cycle
// in this example we average point position with positions of neighbours
// which are above it in world space (their Y coordinate is larger)
int pts[] = neighbours(0, @ptnum);
vector P_avg_upper = {0};
int count = 0;
foreach(int nb_ptnum; pts) {
    vector pos = point(0, "P", nb_ptnum);
    if (pos.y <= v@P.y) continue;
    P_avg_upper += pos;
    count++;
}
P_avg_upper /= count;
v@P = P_avg_upper;





=================Printing and formatting
// Windows ‐ check console window which 
// should pop up automatically
// Linux ‐ run Houdini from command line with 
// the ‐foreground flag to see the output
// manipulating with strings is useful, on only for doing console outputs,
// but also for generating and stylizing strings, use sprintf() to return a string
// type instead of printing to console
string var_string = "abcdef";
float var_float = 1.23456789;
int var_int = 256;
printf("string: %+10s, float: %10.3f, integer: %‐6d \n", var_string, var_float, var_int);
// string = abcdef
// %[+‐][length]s
// %10s ‐> ____abcdef
// %‐10s ‐> abcdef____
// %+10s ‐> __"abcdef"
// %+‐10s ‐> "abcdef"__
// float = 1.23456789
// %[+‐][0][length][precision]f
// %8.3f ‐> ___1.235
// %‐8.3f ‐> 1.235___
// %08.3f ‐> 0001.235
// %+8.3f ‐> __+1.235 (+ shows sign)
// integer = 256
// %[+‐][0][length]d
// %6d ‐> ___256
// %+6d ‐> __+256
// %‐6d ‐> 256___
// %06d ‐> 000256
printf("\n");
// escaping characters in string
// from my testing it requires 4 more backslashes to escape \n
// when using raw strings, they are automatically escaped, but @ symbol still
// needs to be escaped
// following lines will output the same thing
// 4 backslashes are needed probably because hscript is parsing this text field
// and sending to vop's field, see the node bellow
string a = 'abc \\\\\n \\\\\t v\@P, %04.2f';
string b = "abc \\\\\n \\\\\t v\@P, %04.2f";
string c = r"abc \n \t v\@P, %04.2f";
string d = R"(abc \n \t v\@P, %04.2f)";
printf(a + "\n");
printf(b + "\n");
printf(c + "\n");
printf(d + "\n");
string multiLine = 
R"(It is possible to easily create multi
line strings with this syntax.
In some cases it might
be useful to do it this way,
rather then using \n
However as you have noticed it has weird
4 characters offset starting on the second line,
not sure if it is a bug or feature)";
printf(multiLine);
printf("\n\n");

=========================================================


=======================Printing attributes
printf("s\@shop_materialpath (string): %+s, v\@P (vector): %+‐10.3f, \@ptnum (integer): %5d \n", s@shop_materialpath, v@P, @ptnum);
printf("\n\n");
=========================================================


=========================Including external VEX files
#include "myLib.h"
// files located in $HIP/vex/include,
// $HOME/houdiniXX.X/vex/include,
// $HH/vex/include// can be included in wrangles
// to refresh updated header files, 
// promote the "Force Compile" button 
// from the attribvop1 inside of this node, 
// or do a change (add a space somewhere) 
// in code and press Ctrl+Enter
myRemPoints(@ptnum);
From myLib.h:
// void functions do not return anything
// "function" word is not required
function void myRemPoints(int ptnum) {
 if (ptnum > 30)
     removepoint(0, ptnum);
}




=========================================================


============Using macros
#include "myLib.h"
// check attributes in Geometry Spreadsheet, 
// they will match values from myLib.h// use constants
i@my_int = MY_INT;
f@my_float = MY_FLOAT;
HiQPdf Evaluation 02.13.2018
// use function alias
f@renamed_power = RENAMEDPOWER(2,2);
// use macro function
i@add_ten = ADDTEN(10);
From myLib.h:
// you can define constants and use them in your code
#define MY_INT   123
#define MY_FLOAT  3.1415926
// you can also create alias to the function
#define RENAMEDPOWER pow
// or use macros for defining new functions
#define ADDTEN(val)   val+10

==========================================================




=========Functions
#include "myLib.h"
// void does not return anything
myRemPoints(@ptnum);
// arguments are passed as references ‐ fucntion can modify their original value
scaleByTen(v@P);
// you can prevent voids from modifying variable references
// just to be safe :)
int a = 1;
int b = 1;
int c = 1;
changeA(a, b, c);
i@a = a;
i@b = b;
i@c = c;
// functions can also output different types ‐ float, string, int, custom struct...
// they can also output an array of any of those types
vector4 seeds = {1.23,4,56.489,0.849};
f@superRandom = superRandom(seeds);
// function returning array of int(s)
int items = 9;
i[]@items = range(items);
From myLib.h:
// void functions do not return anything
// "function" word is not required
function void myRemPoints(int ptnum) {
 if (ptnum > 30)
     removepoint(0, ptnum);
}
// function parameters are passed by reference automatically, without additional syntax
// (function can modify value of original variable, not its copy)
void scaleByTen(vector P) {
 P *= 10;
}
// you can prevent changing input variable references
void changeA(int a; const int b; int c) {
 a += 10;
 //b += 10; // uncommenting this line will result in error
 c = a;
 c += 4; // even though arguments are passed as references, they are not true references, c is still independent from a
}
// a function returning float value
float superRandom(vector4 seeds) {
 float out = rand(seeds.x * seeds.y * seeds.z * seeds.w);
 return out;
}
// a function returnig an array
int[] range(int max) {
 int out[];
 for(int i=0; i<max; i++) push(out, i);
 return out;
}
==========================================================



=========Functions overloading
#include "myLib.h"
float rand = chf("randomness");
// visualize Normals in the viewport to see the effect
//v@N = randomizeN(v@N, rand, @ptnum + @Frame); // randomizeN(vector, float, float)
// however we can overload our function to accept different set of arguments
vector4 seed;
seed = set(v@P.x, v@P.y, v@P.z, @ptnum * @Frame);
//seed = set(v@P, @ptnum * @Frame); // this does not work as might be expected
v@N = randomizeN(v@N, rand, seed); // randomizeN(vector, float, vector4)
// we can also overload functions to return different type
float randVal;
randVal = float( randomizeN(v@N, rand, @ptnum) );
//randVal = randomizeN(v@N, rand, @ptnum); // this has the same result now, but sometimes VEX might choose other function declaration
v@Cd = randVal;
//v@Cd = set(randVal, randVal, randVal); // this is equivalent to the previous line
p@a = set(v@P.x, v@P.y, v@P.z, 4);
//p@a = set(v@P, 4); // uncomment this line and see the difference in geometry sphreadsheet


==From myLib.h:
// normalize Normal vector by amount [0..1] with specified seed value
vector randomizeN(vector N; float amount, seed) {
 vector randDir;
 
 // getting different random value for each axis, scaling to [‐1..1] range
 randDir.x = rand(seed * 684.49848) * 2 ‐ 1;
 randDir.y = rand(seed * 178.46548) * 2 ‐ 1;
 randDir.z = rand(seed * 489.49856) * 2 ‐ 1;
 
 randDir = normalize(randDir);
 N = lerp(N, randDir, amount);
 N = normalize(N);
 return N;
}
// function has different set of arguments, but the same name
vector randomizeN(vector N; float amount; vector4 seed) {
 vector randDir;
 
 // getting different random value for each axis, scaling to [‐1..1] range
 randDir.x = rand(seed.x * 684.49848 * seed.w) * 2 ‐ 1;
 randDir.y = rand(seed.y * 178.46548 * seed.w) * 2 ‐ 1;
 randDir.z = rand(seed.z * 489.49856 * seed.w) * 2 ‐ 1;
 
 randDir = normalize(randDir);
 N = lerp(N, randDir, amount);
 N = normalize(N);
 return N;
}
// this function declaration returns different type
// the function name does not really match its functionality, its just for the example
float randomizeN(vector N; float amount; int seed) {
 float randDir;
 
 // getting different random value for each axis, scaling to [‐1..1] range
 randDir = rand((float)seed * 684.49848) * 2 ‐ 1;
 return randDir;
}



=======Structs

#include "myLib.h"
// in this node I will show some examples of using structs, they will be defined in myLib.h
// for defining structs inside a wrangle, see node below
// declare struct variable, member data will have default values
myCustomMatrix A;
myCustomMatrix B;
// change values of data in A
A.uniformScale = 2.5;
A.comment = "a very useful struct";
pop(A.myArray);
pop(A.myArray);
push(A.myArray, 7);
// check Geometry Spreadsheet for values of variables in A and B
f@myPiA = A.myPi; // 3.14
f@myPiB = B.myPi; // 3.14
f@uniformScaleA = A.uniformScale; // 2.5
f@uniformScaleB = B.uniformScale; // 1.0
s@commentA = A.comment; // a very useful struct
s@commentB = B.comment; // default comment
f[]@myArrayA = A.myArray; // [ 1.0, 7.0 ]
f[]@myArrayB = B.myArray; // [ 1.0, 3.0, 3.0 ]
v@xA = A.x; // {0,0,0}
v@xB = B.x; // {0,0,0}
// one way of initializing a struct (as explicit struct)
hipFile myProjectA = {"project_A", "hipnc", 1};
s@baseA = myProjectA.base; // project_A
s@extA = myProjectA.ext; // hipnc
i@verA = myProjectA.version; // 1
// another way (initialize using constructor)
hipFile myProjectB = hipFile("project_B", "hip", 1);
s@baseB = myProjectB.base; // project_B
s@extB = myProjectB.ext; // hip
i@verB = myProjectB.version; // 1
// you can call methods in structs with ‐> operator
int versionA = myProjectA‐>incVersion();
versionA = myProjectA‐>incVersion();
versionA = myProjectA‐>incVersion();
int versionB = myProjectB‐>incVersion();
// printName is our another struct method,
// check your terminal output
myProjectA‐>printName(); // this file has name: project_A_004.hipnc
myProjectB‐>printName(); // this file has name: project_B_002.hip
// we can use functions operating on our structs and accessing their datai@match1 = compareHipFiles(myProjectA, myProjectB); // 0
HiQPdf Evaluation 02.13.2018
// now let's make them identical
myProjectB.base = "project_A";
myProjectB.ext = "hipnc";
myProjectB.version = 4;
// and check if they really are :)
i@match2 = compareHipFiles(myProjectA, myProjectB); // 1
// we can also create functions which return hipFile type
// this function expects comma separated list of files and will return
// first occurance of a hip file (with .hip or .hipnc extension)
string files1 = "image1.jpg,image2.png,text.pdf,awesome_tutorial_jtomori_003.hipnc,tutorial.h";
hipFile first = findFirstHipFile(files1);
s@first = first‐>getFullName();
// in VEX we can also output error with custom message, uncomment line bellow and check
// node's error message
string files2 = "image1.jpg,image2.png";
//hipFile second = findFirstHipFile(files2); // No houdini project found in this file list: "image1.jpg,image2.png".
// we can also output an array of hipFiles
// this function will find all Houdini project files and will return array of hipFile(s)
string files3 = "dust_024.hip,img7.tif,odforce_file_001.hipnc,render1.exr,blood_123.hip,notes.txt";
hipFile allHips[] = findAllHipFiles(files3);
// let's check it by adding it into a string array attribute
s[]@allHips;
foreach(hipFile i;allHips) {
    push(s[]@allHips, i‐>getFullName());
}
// result: [ dust_024.hip, odforce_file_001.hipnc, blood_123.hip ]
From myLib.h:
// vex also supoorts structs and methods associated with them
struct myCustomMatrix {
 // uninitialized variables
 vector x, y, z;
 
 // variables with default values
 vector translate = {0,0,0};
 string comment = 'default comment';
 float myPi = 3.14159265;
 float uniformScale = 1.0;
 float myArray[] = {1,2,3};
}
// struct for carrying information about our project file
struct hipFile {
 string base, ext;
 int version = 1;
 // you can create methods that operate on structs
 // this method increases version by 1 and returns new version number
 int incVersion() {
  this.version++;
  return this.version;
 }
 // inside a struct function, you can refer to struct fields by name as if they 
 // were variables (for example, base is a shortcut for this.base).
 // this method writes to console window / terminal
 void printName() {
  printf("this file has name: %s_%03d.%s\n", base, version, ext);
 }
 // returns a string with full file name
 string getFullName() {
  return sprintf("%s_%03d.%s", this.base, this.version, this.ext);
 }
}
// we can create functions that operate on our structs and use their methods
int compareHipFiles(hipFile A, B) {
 int match = 0;
 if (A‐>getFullName() == B‐>getFullName()) match = 1;
 return match;
}
// func returning hipFile type
// this function expects comma separated list of filenames and will 
// return the first occurance of a hip file
hipFile findFirstHipFile(string text) {
 string inFiles[] = split(text, ",");
 string hipParts[];
 foreach(string file; inFiles) {
  string parts[] = split(file, ".");
  if (parts[‐1] == "hip" || parts[‐1] == "hipnc") {
   hipParts = parts;
   break;
  }
 }HiQPdf Evaluation 02.13.2018
 // we can also return error state, warning() function is also available
 if (len(hipParts) == 0) error("No houdini project found in this file list: %+s.", text);
 string prefix[] = split(hipParts[0], "_");
 int ver = atoi( prefix[‐1] );
 string base = join( prefix[:‐1], "_");
 string ext = hipParts[1];
 hipFile out = hipFile(base, ext, ver);
 return out;
}
// we can as well return an array of structs
hipFile[] findAllHipFiles(string text) {
 string inFiles[] = split(text, ",");
 hipFile hips[];
 foreach(string file; inFiles) {
  string parts[] = split(file, ".");
  if (parts[‐1] == "hip" || parts[‐1] == "hipnc") {
   string prefix[] = split(parts[0], "_");
   int ver = atoi( prefix[‐1] );
   string base = join( prefix[:‐1], "_");
   string ext = parts[1];
   hipFile out = hipFile(base, ext, ver);
   push(hips, out);
  }
 }
 // output a warning when no Houdini projects were found
 if (len(hips) == 0) warning("No Houdini projects found.");
 return hips;
}



=======================================














============Attribute typeinfo
/*
It is possible to assign a meaning to attributes. Houdini will understand this meaning and
will treat attributes in a specific way based on it. For example a Transform SOP operates
on P attribute, but will also modify N attribute accordingly. For modifying this behavior 
we can use setattribtypeinfo() function which can set typeinfo to attributes.
You can check which typeinfo an attribute has by middle‐clicking on a node and checking value
in brackets, e.g. P (pos) ‐ this means point typeinfo
You can chceck list of available typeinfos in the docs, or below:
none ‐ No transformations should be applied.
point ‐ Scales, rotations and translations should be applied.
hpoint ‐ A four‐vector with scales, rotations and translations applied.
vector ‐ Scales and rotations should be applied.
normal ‐ Scales and rotations should be applied. Scales are applied with inverse‐transpose.
color ‐ No transformations.
matrix ‐ A 4×4 matrix with scale, rotations, and translations applied.
quaternion ‐ A four‐vector with rotations applied.
indexpair ‐ No transformations.
integer ‐ Integer values that do not blend when points are averaged.
integer‐blend ‐ Integer values that blend when points are averaged.
*/
// set color to green
v@Cd = {0,1,0};
// initialize N attribute, which will get automatically get values
v@N;
// change typeinfos of Cd and N to see funky results after modifying geometry with Transform SOP
setattribtypeinfo(0, "point", "Cd", "point");
setattribtypeinfo(0, "point", "N", "color");
=======================================



==============Structs in Attribute Wrangle
// VEX does not allow defining structs inside this field, they need to be defined
// externally, either in a .h file, or in "Outer Code" string parameter of "snippet1"
// which is inside of every Wrangle node (this > attribvop1 > snippet1)
// in this case I unlocked the wrangle and promoted "Outer Code" parameter from 
// the inside of snippet1 to this wrangle
hipFile A = hipFile("awesome_vex_examples_file","hipnc",3);
s@A = A.base;
// uncommenting of the following lines will result in an error
/*
struct hipFileB {
        string base, ext;
        int version = 1;
}
*/
// Outer Code behaves just like a .h file included
i@my_int = MY_INT;
Outer Code
struct hipFile {
        string base, ext;
        int version = 1;
}
#define MY_INT  123456


============Enforce prototypes
// If we want to be more organized, we can use "Enforce Prototypes" option 
// in Wrangles, it is handy with larger code projects as it helps with 
// managing attributes and simplifies syntax for accesing them (especially with arrays)
// initialize attribute "Prototypes" ‐ here we need to specify all attributes
// that we want to use/create, it also applies to default/global attributes 
// like v@P, @Frame, @ptnum
vector @P;
vector @Cd;
int @ptnum;
float @Frame;
float @new_attrib = 4; // we can also set initial value, but without any expressions
int @new_int_array_attrib[];
// we can still use local variables in a standard way
float A = @Frame * .5;
int B = 4;
// now we can use attributes without their signature before @ sign
@P += set(0, B, 0);
@Cd *= rand(@ptnum);
@new_attrib *= A;
@new_int_array_attrib = {1,2,3,4};
==============================















