{"body": [{"indent": 0, "text": ["Constraint Network"], "type": "title", "extent": [85, 108], "level": 0}, {"indent": 0, "type": "summary", "extent": [108, 189], "text": ["Constrains pairs of RBD objects together according to a polygon network."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [195, 332], "text": ["This DOP is currently only supported by the ", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, "\n    and the ", {"text": ["Wire Solver"], "fullpath": "/nodes/dop/wiresolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/wiresolver"}, "."]}], "indent": 0, "role": "item", "type": "note", "extent": [189, 195]}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "extent": [332, 422], "text": ["The constraint network defines pairs of RBD objects that should be constrained\ntogether."]}, {"indent": 0, "type": "para", "extent": [422, 879], "text": ["With the constraint network, SOP Geometry is specified which defines what\nobjects should be constrained. This makes it easy to procedurally generate a\nset of constraint relationships, including constraints of different types. Each\npoint in the geometry represents a constraint anchor, according to the ", {"text": ["name"], "type": "code"}, "\nand ", {"text": ["P"], "type": "code"}, " attributes. Each two-point polygon represents a constraint, according\nto the constraint data specified by the ", {"text": ["constraint_name"], "type": "code"}, " attribute."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [884, 1079], "text": ["Advanced users can use the ", {"text": ["constraint_name"], "type": "code"}, " and ", {"text": ["constraint_type"], "type": "code"}, "\n        attributes to dynamically change constraint types with animation or a\n        ", {"text": ["SOP Solver"], "fullpath": "/nodes/dop/sopsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/sopsolver"}, "."]}], "indent": 0, "role": "item", "type": "tip", "extent": [879, 884]}], "container": true, "role": "item_group", "type": "tip_group"}, {"body": [{"indent": 0, "type": "para", "extent": [1117, 1631], "text": ["If a constraint is broken by a solver (such as when sufficient force is applied\nto break a glue bond), the primitive will be placed into a primitive group\nnamed ", {"text": ["broken"], "type": "code"}, ". That primitive group can be used in a ", {"text": ["SOP Solver"], "fullpath": "/nodes/dop/sopsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/sopsolver"}, "\nto trigger events such as emitting debris when a constraint breaks. Any\nconstraints that are in the ", {"text": ["broken"], "type": "code"}, " primitive group will be ignored by solvers\non subsequent frames. Currently, only glue constraints will be broken by the\n", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, "."]}, {"indent": 0, "type": "para", "extent": [1631, 2394], "text": ["Constraints can also be broken by using a SOP Solver to delete primitives from\nthe constraint network\u2019s geometry. For linear constraints, the ", {"text": ["force"], "type": "code"}, " and\n", {"text": ["distance"], "type": "code"}, " primitive attributes are updated by the solver to contain the force\napplied to satisfy the constraint and the distance between the anchors,\nrespectively. For angular constraints, the ", {"text": ["torque"], "type": "code"}, " and ", {"text": ["angle"], "type": "code"}, " primitive\nattributes are updated by the solver to contain the torque applied to satisfy\nthe constraint and the angle (in radians) between the anchors. For ", {"text": ["glue\nconstraints"], "fullpath": "/nodes/dop/glueconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/glueconrel"}, ", the ", {"text": ["impact"], "type": "code"}, " primitive attribute is updated\nby the solver to contain the accumulated impulses for the glue bond. These\nattributes can be used to remove a constraint when certain conditions are met."]}], "indent": 0, "level": 2, "text": ["Breaking Constraints"], "extent": [1079, 1117], "container": true, "type": "h", "id": "breaking"}, {"body": [{"indent": 0, "type": "para", "extent": [2427, 2656], "text": ["Each point in the constraint geometry represents an anchor. All constraints are\nmade up of two anchors.  Currently there are 4 different types of anchors,\nspecified by the ", {"text": ["name"], "type": "code"}, ", ", {"text": ["anchor_type"], "type": "code"}, " and ", {"text": ["anchor_id"], "type": "code"}, " point attributes."]}, {"indent": 0, "type": "para", "extent": [2656, 2981], "text": ["A World Space Anchor is an anchor that is simply placed at a static world space\nposition, specified by the ", {"text": ["P"], "type": "code"}, " attribute on the anchor. If an anchor has an\nempty value for the ", {"text": ["name"], "type": "code"}, " attribute, then the anchor is treated as a World\nSpace Anchor. If the ", {"text": ["name"], "type": "code"}, " attribute specifies an invalid name, the constraint\nis skipped."]}, {"indent": 0, "type": "para", "extent": [2981, 3468], "text": ["A Relative Offset Anchor is an anchor that is placed at specific position\nrelative to a simulated object. This position is fixed to the object\u2019s initial\nrotation, so if the object is rotated during the simulation the anchor rotates\nwith it. If the ", {"text": ["name"], "type": "code"}, " attribute specifies a valid object, and the ", {"text": ["anchor_id"], "type": "code"}, "\nattribute is set to ", {"text": ["-1"], "type": "code"}, " (or is not defined), then the anchor is treated as a\nRelative Offset Anchor, with the ", {"text": ["P"], "type": "code"}, " attribute specifying the offset from the\nobject\u2019s centroid."]}, {"indent": 0, "type": "para", "extent": [3468, 3922], "text": ["A Point Anchor is an anchor whose position is bound to that of a certain point\non the geometry of a simulated object. When the ", {"text": ["name"], "type": "code"}, " attribute is valid and\nthe ", {"text": ["anchor_id"], "type": "code"}, " attribute is a valid point index, then the anchor will be\nplaced at the specified point. Alternatively, if the ", {"text": ["anchor_type"], "type": "code"}, " attribute is\nset to ", {"text": ["vertex"], "type": "code"}, " (the default is ", {"text": ["point"], "type": "code"}, ") then the anchor will be placed at the\npoint referred to by the vertex with the index in ", {"text": ["anchor_id"], "type": "code"}, "."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [3928, 4358], "text": ["In cases where the geometry of a simulated object changes over the course\n    of a simulation, anchoring to a point by specifying a point (or vertex)\n    index in the ", {"text": ["anchor_id"], "type": "code"}, " attribute may not yield correct results. This is\n    because as the geometry changes, point and vertex indices may also change,\n    meaning the Point Anchors could end up referring to different points than\n    at the beginning of the simulation."]}, {"indent": 4, "type": "para", "extent": [4358, 4808], "text": ["To fix this, add the integer point attribute ", {"text": ["anchor_pid"], "type": "code"}, " or the integer\n    vertex attribute ", {"text": ["anchor_vid"], "type": "code"}, " to the simulated object whose geometry may\n    change. If either of these attributes exist, then the ", {"text": ["anchor_id"], "type": "code"}, " specified\n    on the anchor will match to the first point (or vertex) with the same\n    ", {"text": ["anchor_pid"], "type": "code"}, " (or ", {"text": ["anchor_vid"], "type": "code"}, ") value on the simulated geometry. This way as\n    the geometry changes, the attributes will stay the same."]}], "indent": 0, "role": "item", "type": "note", "extent": [3922, 3928]}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 0, "type": "para", "extent": [4808, 5265], "text": ["An Agent Anchor is an anchor that is attached to a transform in an agent\u2019s rig.\nThe transform does not need to be associated with a simulated object (i.e. the agent\u2019s collision layer does not need to have a shape attached to the transform).\nWhen the ", {"text": ["anchor_type"], "type": "code"}, " is ", {"text": ["agent"], "type": "code"}, " and the ", {"text": ["name"], "type": "code"}, " attribute references an agent\u2019s transform (e.g. ", {"text": ["agent1/head"], "type": "code"}, "), the ", {"text": ["local_P"], "type": "code"}, " and ", {"text": ["local_orient"], "type": "code"}, " attributes can be used to specify the local transform of the anchor."]}], "indent": 0, "level": 2, "text": ["Anchor Types"], "extent": [2394, 2427], "container": true, "type": "h", "id": "anchortypes"}, {"body": [{"body": [{"indent": 0, "type": "para", "extent": [46, 345], "text": ["You can ", {"text": ["create attributes"], "fullpath": "/model/attributes", "scheme": null, "type": "link", "value": "/model/attributes"}, " on the geometry to customize each constraint\u2019s behavior and type.\nIf a primitive attribute with the same name as a constraint property (such as ", {"text": ["damping"], "type": "code"}, ") is present, the attribute value will be multiplied with the value from the constraint sub-data."]}, {"indent": 0, "type": "para", "extent": [345, 446], "text": ["The following attributes can be used to control the type of constraint described by each primitive."]}, {"body": [{"body": [{"indent": 8, "text": [" Name"], "tag": "th", "attrs": {}, "extent": [463, 481], "type": "pxml"}, {"indent": 8, "text": [" Class"], "tag": "th", "attrs": {}, "extent": [481, 500], "type": "pxml"}, {"indent": 8, "text": [" Type"], "tag": "th", "attrs": {}, "extent": [500, 518], "type": "pxml"}, {"indent": 8, "text": [" Description"], "tag": "th", "attrs": {}, "extent": [518, 543], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [454, 463], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["constraint_name"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [552, 583], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [583, 606], "type": "pxml"}, {"indent": 8, "text": [" String"], "tag": "td", "attrs": {}, "extent": [606, 626], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [639, 986], "text": ["Specifies the ", {"text": ["Data Name"], "type": "ui"}, " of the constraint to create. If this\n            attribute is not present or the name is invalid, no constraint will\n            be created from the primitive. This attribute can be modified in a\n            ", {"text": ["SOP Solver"], "fullpath": "/nodes/dop/sopsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/sopsolver"}, " to change the constraint\u2019s type\n            during the simulation."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [626, 639], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [543, 552], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["constraint_type"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [995, 1026], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [1026, 1049], "type": "pxml"}, {"indent": 8, "text": [" String"], "tag": "td", "attrs": {}, "extent": [1049, 1069], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [1082, 1307], "text": ["Specifies whether the constraint affects ", {"text": ["position"], "type": "code"}, ", ", {"text": ["rotation"], "type": "code"}, " or\n            ", {"text": ["all"], "type": "code"}, " degrees of freedom. If this attribute is not present or has\n            an invalid value, the default value will be ", {"text": ["position"], "type": "code"}, "."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [1069, 1082], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [986, 995], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["next_constraint_name"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [1316, 1352], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [1352, 1375], "type": "pxml"}, {"indent": 8, "text": [" String"], "tag": "td", "attrs": {}, "extent": [1375, 1395], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [1408, 1810], "text": ["Specifies a new value for the ", {"text": ["constraint_name"], "type": "code"}, " attribute to switch to if the constraint is broken by the solver.\n            This is simpler than using a ", {"text": "", "fullpath": "/nodes/dop/sopsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/sopsolver"}, " and allows the transition to take place at the instant the constraint breaks.\n            Currently, only ", {"text": ["glue constraints"], "fullpath": "/nodes/dop/glueconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/glueconrel"}, " may be broken during the timestep by the ", {"text": "", "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, "."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [1395, 1408], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [1307, 1316], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["next_constraint_type"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [1819, 1855], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [1855, 1878], "type": "pxml"}, {"indent": 8, "text": [" String"], "tag": "td", "attrs": {}, "extent": [1878, 1898], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [1911, 2087], "text": ["Specifies a new value for the ", {"text": ["constraint_type"], "type": "code"}, " attribute to switch to if the constraint is broken by the solver and the ", {"text": ["next_constraint_name"], "type": "code"}, " attribute is valid."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [1898, 1911], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [1810, 1819], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["propagate_iteration"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [2096, 2131], "type": "pxml"}, {"indent": 8, "text": [" Detail"], "tag": "td", "attrs": {}, "extent": [2131, 2151], "type": "pxml"}, {"indent": 8, "text": [" Integer"], "tag": "td", "attrs": {}, "extent": [2151, 2172], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [2185, 2310], "text": ["Specifies the number of impact propagations for all ", {"text": ["glue bonds"], "fullpath": "/nodes/dop/glueconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/glueconrel"}, " in the constraint network."]}, {"body": [{"body": [{"indent": 16, "type": "para", "extent": [2328, 2526], "text": ["In Houdini 17, the number of propagation iterations can instead be varied per glue constraint with the ", {"text": ["Propagation Iterations"], "type": "ui"}, " parameter, so this detail attribute is deprecated."]}], "indent": 12, "role": "item", "type": "note", "extent": [2310, 2328]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 8, "tag": "td", "attrs": {}, "extent": [2172, 2185], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [2087, 2096], "type": "pxml"}], "indent": 0, "tag": "table", "attrs": {}, "extent": [446, 454], "type": "pxml"}], "indent": 0, "level": 3, "text": ["Constraint Attributes"], "extent": [16, 46], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2554, 2801], "text": ["The following attributes are created by the solver to provide information about how the constraints behaved during the previous timestep.\nThese attributes can be used to control when ", {"fragment": "#breaking", "text": ["constraints are broken"], "value": "/nodes/dop/constraintnetwork#breaking", "fullpath": "/nodes/dop/constraintnetwork#breaking", "scheme": "Node", "type": "link"}, "."]}, {"body": [{"body": [{"indent": 8, "text": [" Name"], "tag": "th", "attrs": {}, "extent": [2818, 2836], "type": "pxml"}, {"indent": 8, "text": [" Class"], "tag": "th", "attrs": {}, "extent": [2836, 2855], "type": "pxml"}, {"indent": 8, "text": [" Type"], "tag": "th", "attrs": {}, "extent": [2855, 2873], "type": "pxml"}, {"indent": 8, "text": [" Description"], "tag": "th", "attrs": {}, "extent": [2873, 2898], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [2809, 2818], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["angle"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [2907, 2928], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [2928, 2951], "type": "pxml"}, {"indent": 8, "text": [" Float"], "tag": "td", "attrs": {}, "extent": [2951, 2970], "type": "pxml"}, {"indent": 8, "text": [" The current angle (in radians) between the two anchors."], "tag": "td", "attrs": {}, "extent": [2970, 3039], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [2898, 2907], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["distance"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [3048, 3072], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [3072, 3095], "type": "pxml"}, {"indent": 8, "text": [" Float"], "tag": "td", "attrs": {}, "extent": [3095, 3114], "type": "pxml"}, {"indent": 8, "text": [" The current distance between the two anchors."], "tag": "td", "attrs": {}, "extent": [3114, 3173], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [3039, 3048], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["force"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [3182, 3203], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [3203, 3226], "type": "pxml"}, {"indent": 8, "text": [" Float"], "tag": "td", "attrs": {}, "extent": [3226, 3245], "type": "pxml"}, {"indent": 8, "text": [" This attribute stores the magnitude of the force that was applied to satisfy the constraint during the previous timestep."], "tag": "td", "attrs": {}, "extent": [3245, 3380], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [3173, 3182], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["impact"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [3389, 3411], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [3411, 3434], "type": "pxml"}, {"indent": 8, "text": [" Float"], "tag": "td", "attrs": {}, "extent": [3434, 3453], "type": "pxml"}, {"indent": 8, "text": [" For ", {"text": ["glue constraints"], "fullpath": "/nodes/dop/glueconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/glueconrel"}, ", this attribute is updated by the solver with the accumulated impulses for the glue bond, as impacts occur and propagate through the network."], "tag": "td", "attrs": {}, "extent": [3453, 3651], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [3380, 3389], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["torque"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [3660, 3682], "type": "pxml"}, {"indent": 8, "text": [" Primitive"], "tag": "td", "attrs": {}, "extent": [3682, 3705], "type": "pxml"}, {"indent": 8, "text": [" Float"], "tag": "td", "attrs": {}, "extent": [3705, 3724], "type": "pxml"}, {"indent": 8, "text": [" This attribute stores the magnitude of the torque that was applied to satisfy the constraint during the previous timestep."], "tag": "td", "attrs": {}, "extent": [3724, 3860], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [3651, 3660], "type": "pxml"}], "indent": 0, "tag": "table", "attrs": {}, "extent": [2801, 2809], "type": "pxml"}], "indent": 0, "level": 3, "text": ["Feedback Attributes"], "extent": [2526, 2554], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [3887, 4025], "text": ["The following attributes can be used to control how the anchor points are ", {"fragment": "#anchortypes", "text": ["attached to objects"], "value": "/nodes/dop/constraintnetwork#anchortypes", "fullpath": "/nodes/dop/constraintnetwork#anchortypes", "scheme": "Node", "type": "link"}, "."]}, {"body": [{"body": [{"indent": 8, "text": [" Name"], "tag": "th", "attrs": {}, "extent": [4042, 4060], "type": "pxml"}, {"indent": 8, "text": [" Class"], "tag": "th", "attrs": {}, "extent": [4060, 4079], "type": "pxml"}, {"indent": 8, "text": [" Type"], "tag": "th", "attrs": {}, "extent": [4079, 4097], "type": "pxml"}, {"indent": 8, "text": [" Description"], "tag": "th", "attrs": {}, "extent": [4097, 4122], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [4033, 4042], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["anchor_id"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [4131, 4156], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [4156, 4175], "type": "pxml"}, {"indent": 8, "text": [" Integer"], "tag": "td", "attrs": {}, "extent": [4175, 4196], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [4209, 4506], "text": ["If this attribute is defined and refers to a valid point (or vertex depending\n            on the value of ", {"text": ["anchor_type"], "type": "code"}, "), then this anchor\u2019s position will be bound to\n            the specified point (or vertex) on the simulated geometry specified by the\n            ", {"text": ["name"], "type": "code"}, " attribute."]}, {"indent": 12, "type": "para", "extent": [4506, 4821], "text": ["If the value is set to ", {"text": ["-1"], "type": "code"}, ", then the anchor is treated as a relative offset\n            from the object specified by the ", {"text": ["name"], "type": "code"}, " attribute (where the ", {"text": ["P"], "type": "code"}, " attribute\n            defines the offset). If the value does not refer to a valid point (or vertex),\n            then the constraint is not created."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [4196, 4209], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [4122, 4131], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["anchor_type"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [4830, 4857], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [4857, 4876], "type": "pxml"}, {"indent": 8, "text": [" Integer"], "tag": "td", "attrs": {}, "extent": [4876, 4897], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [4910, 5231], "text": ["Specifies if the anchor is attached to a ", {"text": ["point"], "type": "code"}, ", ", {"text": ["vertex"], "type": "code"}, " or ", {"text": ["agent"], "type": "code"}, " transform.\n            If no ", {"text": ["anchor_id"], "type": "code"}, " attribute is defined and the anchor type is ", {"text": ["point"], "type": "code"}, " or ", {"text": ["vertex"], "type": "code"}, ", then this\n            attribute has no effect.\n            If this attribute is not defined, then ", {"text": ["anchor_id"], "type": "code"}, " will refer to a point."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [4897, 4910], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [4821, 4830], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["condir"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [5240, 5262], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [5262, 5281], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [5281, 5301], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [5314, 5652], "text": ["If the number of constrained degrees of freedom is 1, this value\n            defines the normal of a plane that the object can move along or\n            rotate about any axis in. If the number of constrained degrees of\n            freedom is 2, this value defines an axis that the object can move\n            or rotate about."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [5301, 5314], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [5231, 5240], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["condof"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [5661, 5683], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [5683, 5702], "type": "pxml"}, {"indent": 8, "text": [" Integer"], "tag": "td", "attrs": {}, "extent": [5702, 5723], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [5736, 5840], "text": ["Identifies the number of constrained degrees of freedom for an\n            anchor (0 to 3)."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [5723, 5736], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [5652, 5661], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["local_orient"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [5849, 5877], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [5877, 5896], "type": "pxml"}, {"indent": 8, "text": [" Quaternion"], "tag": "td", "attrs": {}, "extent": [5896, 5920], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [5933, 6075], "text": ["If the ", {"text": ["anchor_type"], "type": "code"}, " is ", {"text": ["agent"], "type": "code"}, ", specifies the anchor\u2019s orientation in the local space of the transform referenced by the ", {"text": ["name"], "type": "code"}, "."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [5920, 5933], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [5840, 5849], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["local_P"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [6084, 6107], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [6107, 6126], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [6126, 6146], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [6159, 6298], "text": ["If the ", {"text": ["anchor_type"], "type": "code"}, " is ", {"text": ["agent"], "type": "code"}, ", specifies the anchor\u2019s position in the local space of the transform referenced by the ", {"text": ["name"], "type": "code"}, "."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [6146, 6159], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [6075, 6084], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["name"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [6307, 6327], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [6327, 6346], "type": "pxml"}, {"indent": 8, "text": [" String"], "tag": "td", "attrs": {}, "extent": [6346, 6366], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [6379, 6546], "text": ["Identifies the object to which the constraint is attached.\n            An empty name indicates that the constraint is attached to a world space position."]}, {"indent": 12, "type": "para", "extent": [6546, 7091], "text": ["For ", {"text": ["RBD Packed Objects"], "fullpath": "/nodes/dop/rbdpackedobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdpackedobject"}, ", the ", {"text": ["name"], "type": "code"}, " point attribute from the DOP object\u2019s geometry is used to identify which object to attach the constraint to.\n            This can be prefixed by the DOP Object name (e.g. ", {"text": ["object2/piece3"], "type": "code"}, ") to uniquely identify the object.\n            For agent primitives, a transform name can be appended to the anchor name (e.g. ", {"text": ["agent2/head"], "type": "code"}, ") to attach the constraint to a specific transform in the agent\u2019s rig.\n            For all other types of objects, the DOP object name is used."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [6366, 6379], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [6298, 6307], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["orient"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [7100, 7122], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [7122, 7141], "type": "pxml"}, {"indent": 8, "text": [" Quaternion"], "tag": "td", "attrs": {}, "extent": [7141, 7165], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [7178, 7369], "text": ["Identifies the initial world space orientation of the anchor. If\n            the ", {"text": ["r"], "type": "code"}, " point attribute also exists on the geometry, this attribute\n            will take precedence."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [7165, 7178], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [7091, 7100], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["P"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [7378, 7395], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [7395, 7414], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [7414, 7434], "type": "pxml"}, {"indent": 8, "text": [" Identifies the initial world space position of the anchor."], "tag": "td", "attrs": {}, "extent": [7434, 7506], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [7369, 7378], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["r"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [7515, 7532], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [7532, 7551], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [7551, 7571], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [7584, 7686], "text": ["Identifies the initial world space orientation of the anchor as\n            Euler angles."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [7571, 7584], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [7506, 7515], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["v"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [7695, 7712], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [7712, 7731], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [7731, 7751], "type": "pxml"}, {"indent": 8, "text": [" Identifies the velocity of the world space position to which the constraint is attached."], "tag": "td", "attrs": {}, "extent": [7751, 7853], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [7686, 7695], "type": "pxml"}, {"body": [{"indent": 8, "text": [" ", {"text": ["w"], "type": "code"}], "tag": "td", "attrs": {}, "extent": [7862, 7879], "type": "pxml"}, {"indent": 8, "text": [" Point"], "tag": "td", "attrs": {}, "extent": [7879, 7898], "type": "pxml"}, {"indent": 8, "text": [" Vector"], "tag": "td", "attrs": {}, "extent": [7898, 7918], "type": "pxml"}, {"body": [{"indent": 12, "type": "para", "extent": [7931, 8052], "text": ["Identifies the angular velocity of the world space position to\n            which the constraint is attached."]}], "indent": 8, "tag": "td", "attrs": {}, "extent": [7918, 7931], "type": "pxml"}], "indent": 4, "tag": "tr", "attrs": {}, "extent": [7853, 7862], "type": "pxml"}], "indent": 0, "tag": "table", "attrs": {}, "extent": [4025, 4033], "type": "pxml"}], "indent": 0, "level": 3, "text": ["Anchor Attributes"], "extent": [3860, 3887], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [5347, 5863], "text": ["For ", {"text": ["RBD Packed Objects"], "fullpath": "/nodes/dop/rbdpackedobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdpackedobject"}, ", the name point attribute from the DOP object\u2019s geometry is used to identify which object to attach the constraint to. Since multiple ", {"text": ["RBD Packed Objects"], "fullpath": "/nodes/dop/rbdpackedobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdpackedobject"}, " may contain packed primitives with the same names, the identifier can optionally be prefixed by the DOP Object name (e.g. ", {"text": ["object2/piece3"], "type": "code"}, ") to avoid name conflicts and uniquely identify the object. For all other types of objects, the DOP object name is used as the identifier."]}, {"indent": 8, "type": "para", "extent": [5863, 6162], "text": ["When switching a setup from using an ", {"text": ["RBD Packed Object"], "fullpath": "/nodes/dop/rbdpackedobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdpackedobject"}, " to an ", {"text": ["RBD Fractured Object"], "fullpath": "/nodes/dop/rbdfracturedobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdfracturedobject"}, ", ensure that the anchor names are not prefixed with the DOP Object name so that the constraint network is compatible with both object representations."]}], "indent": 0, "role": "item", "type": "note", "extent": [5341, 5347]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "level": 2, "text": ["Attributes"], "extent": [5265, 5295], "container": true, "type": "h", "id": "attributes"}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [6212, 6274], "text": ["Specifies the source of the constraint network geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [6283, 6344], "text": ["Use the SOP specified by the ", {"text": ["SOP Path"], "type": "ui"}, " parameter."]}], "indent": 4, "type": "dt", "extent": [6274, 6283], "text": ["SOP"]}, {"body": [{"indent": 8, "type": "para", "extent": [6372, 6436], "text": ["Use the SOP connected to the DOP network\u2019s first input."]}], "indent": 4, "type": "dt", "extent": [6344, 6372], "text": ["First Context Geometry"]}, {"body": [{"indent": 8, "type": "para", "extent": [6465, 6530], "text": ["Use the SOP connected to the DOP network\u2019s second input."]}], "indent": 4, "type": "dt", "extent": [6436, 6465], "text": ["Second Context Geometry"]}, {"body": [{"indent": 8, "type": "para", "extent": [6558, 6622], "text": ["Use the SOP connected to the DOP network\u2019s third input."]}], "indent": 4, "type": "dt", "extent": [6530, 6558], "text": ["Third Context Geometry"]}, {"body": [{"indent": 8, "type": "para", "extent": [6651, 6717], "text": ["Use the SOP connected to the DOP network\u2019s fourth input."]}], "indent": 4, "type": "dt", "extent": [6622, 6651], "text": ["Fourth Context Geometry"]}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Geometry Source"], "role": "item", "extent": [6194, 6212], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6727, 6786], "text": ["The SOP geometry to use to determine the constraints."]}], "indent": 0, "text": ["SOP Path"], "role": "item", "extent": [6717, 6727], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6808, 6922], "text": ["Turn on this option to embed the transform from the parent object of the\n    SOP along with the geometry.   "]}], "indent": 0, "text": ["Use Object Transform"], "role": "item", "extent": [6786, 6808], "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6942, 7060], "text": ["This flag will re-import the network whenever it is set, allowing a\n    completely animated constraint behavior."]}], "indent": 0, "text": ["Overwrite with SOP"], "role": "item", "extent": [6922, 6942], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Data Options"], "extent": [6174, 6194], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [7106, 7230], "text": ["Turning on this option causes guide geometry to be displayed in\n        the viewport representing this constraint."]}], "indent": 4, "text": ["Show Guide Geometry"], "role": "item", "extent": [7080, 7106], "type": "parameters_item"}, {"body": [{"indent": 8, "type": "para", "extent": [7252, 7376], "text": ["This parameter controls the display of guide geometry\n        connecting the constraint to the constrained object."]}], "indent": 4, "text": ["Show Object Link"], "role": "item", "extent": [7230, 7252], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Guide Options"], "extent": [7060, 7080], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [7438, 8107], "text": ["The default behavior is to attach the constraint geometry to a ", {"text": ["relationship"], "fullpath": "/nodes/dop/applyrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/applyrel"}, " between the objects, which allows constraints to be anchored to multiple DOP objects.\n        If constraints only need to be between packed primitives in a single DOP object, this option allows the constraint geometry to be attached to the DOP object\u2019s ", {"text": ["ConstraintGeometry"], "type": "code"}, " subdata instead of a relationship.\n        In this mode, constraints can be modified during the timestep with a SOP solver that processes the object\u2019s ", {"text": ["ConstraintGeometry"], "type": "code"}, " subdata (for relationships, any attached solvers are run at the beginning of the timestep before solving any objects)."]}], "indent": 4, "text": ["Attach Internal Constraints to Object"], "role": "item", "extent": [7395, 7438], "type": "parameters_item"}, {"body": [{"indent": 8, "type": "para", "extent": [8132, 8204], "text": ["Specifies the affected DOP objects in the created relationship."]}], "indent": 4, "text": ["Constrained Objects"], "role": "item", "extent": [8107, 8132], "type": "parameters_item"}, {"body": [{"indent": 8, "type": "para", "extent": [8227, 8287], "text": ["A unique name that will identify the relationship."]}], "indent": 4, "text": ["Relationship Name"], "role": "item", "extent": [8204, 8227], "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Relationship"], "extent": [7376, 7395], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [55, 270], "text": ["Determines if this node should do anything on a given timestep and\n    for a particular object. If this parameter is an expression, it is\n    evaluated for each object (even if data sharing is turned on). "]}, {"indent": 4, "type": "para", "extent": [270, 461], "text": ["If it evaluates to a non-zero value, then the data is attached to that\n    object. If it evaluates to zero, no data is attached, and data\n    previously attached by this node is removed."]}], "indent": 0, "text": ["Activation"], "role": "item", "attrs": {"channels": "/activation"}, "extent": [15, 27], "type": "parameters_item"}], "container": true, "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [6162, 6174], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [8358, 8483], "text": ["The objects to apply this relationship to, that will be eligible for\n    being constrained by the object name attribute."]}], "indent": 0, "type": "dt", "extent": [8332, 8358], "text": ["Objects To Be Processed"]}, {"body": [{"indent": 4, "type": "para", "extent": [8506, 8592], "text": ["The constraints that can be created using the primitives in the SOP\n    geometry."]}], "indent": 0, "type": "dt", "extent": [8483, 8506], "text": ["Constraints To Create"]}, {"body": [{"indent": 4, "type": "para", "extent": [8612, 8844], "text": ["SOP solvers may be attached to update the constraint network\n    dynamically in response to events. Only a single geometry is shared by\n    all the objects, so this solver is executed once per relationship, not\n    per object."]}], "indent": 0, "type": "dt", "extent": [8592, 8612], "text": ["Constraint Solvers"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "extent": [8324, 8332], "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [29, 296], "text": ["The operation of this output depends on what inputs are connected\n    to this node. If an object stream is input to this node, the output\n    is also an object stream containing the same objects as the input\n    (but with the data from this node attached). "]}, {"indent": 4, "type": "para", "extent": [296, 606], "text": ["If no object stream is\n    connected to this node, the output is a data output. This data\n    output can be connected to an ", {"text": ["Apply Data DOP"], "fullpath": "/nodes/dop/applydata", "scheme": "Node", "type": "link", "value": "/nodes/dop/applydata"}, ",\n    or connected directly to a data input of another data node, to\n    attach the data from this node to an object or another piece of\n    data."]}], "indent": 0, "type": "dt", "extent": [15, 29], "text": ["First Output"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Outputs", "role": "section", "extent": [8844, 8853], "container": true, "type": "outputs_section", "id": "outputs"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "extent": [20, 107], "text": ["This value is the simulation time for which the node is being\n    evaluated. "]}, {"type": "para", "indent": 4, "extent": [107, 326], "text": ["This value may not be equal to the current Houdini time\n    represented by the variable T, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " ", {"text": ["Offset Time"], "type": "ui"}, " and ", {"text": ["Time Scale"], "type": "ui"}, "\n    parameters. "]}, {"type": "para", "indent": 4, "extent": [326, 555], "text": ["This value is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"text": ["$ST == 0"], "type": "code"}, " rather than\n    ", {"text": ["$T == 0"], "type": "code"}, " or ", {"text": ["$FF == 1"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "extent": [16, 20], "text": ["ST"]}, {"body": [{"type": "para", "indent": 4, "extent": [559, 700], "text": ["This value is the simulation frame (or more accurately, the\n    simulation time step number) for which the node is being evaluated."]}, {"type": "para", "indent": 4, "extent": [700, 999], "text": ["This value may not be equal to the current Houdini frame number\n    represented by the variable F, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " parameters. Instead, this value is equal to\n    the simulation time (ST) divided by the simulation timestep size\n    (TIMESTEP)."]}], "type": "dt", "indent": 0, "extent": [555, 559], "text": ["SF"]}, {"body": [{"type": "para", "indent": 4, "extent": [1009, 1181], "text": ["This value is the size of a simulation timestep. This value is\n    useful to scale values that are expressed in units per second, but\n    are applied on each timestep."]}], "type": "dt", "indent": 0, "extent": [999, 1009], "text": ["TIMESTEP"]}, {"body": [{"type": "para", "indent": 4, "extent": [1187, 1305], "text": ["This value is the inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."]}], "type": "dt", "indent": 0, "extent": [1181, 1187], "text": ["SFPS"]}, {"body": [{"type": "para", "indent": 4, "extent": [1312, 1523], "text": ["This is the number of objects in the simulation. For nodes that\n    create objects such as the ", {"text": ["Empty Object"], "fullpath": "/nodes/dop/emptyobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/emptyobject"}, " node,\n    this value will increase for each object that is evaluated. "]}, {"type": "para", "indent": 4, "extent": [1523, 1621], "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"text": ["object_$SNOBJ"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "extent": [1305, 1312], "text": ["SNOBJ"]}, {"body": [{"type": "para", "indent": 4, "extent": [1627, 1859], "text": ["This value is the number of objects that will be evaluated by the\n    current node during this timestep. This value will often be\n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "]}, {"type": "para", "indent": 4, "extent": [1859, 1991], "text": ["This value may return 0 if the node does not\n    process each object sequentially (such as the ", {"text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [1621, 1627], "text": ["NOBJ"]}, {"body": [{"type": "para", "indent": 4, "extent": [1996, 2322], "text": ["This value is the index of the specific object being processed by\n    the node. This value will always run from zero to NOBJ-1 in a given\n    timestep. This value does not identify the current object within the\n    simulation like OBJID or OBJNAME, just the object\u2019s position in the\n    current order of processing. "]}, {"type": "para", "indent": 4, "extent": [2322, 2616], "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    will be -1 if the node does not process objects sequentially (such\n    as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [1991, 1996], "text": ["OBJ"]}, {"body": [{"type": "para", "indent": 4, "extent": [2623, 2883], "text": ["This is the unique object identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. "]}, {"type": "para", "indent": 4, "extent": [2883, 3168], "text": ["The object identifier\n    can always be used to uniquely identify a given object. This makes\n    this variable very useful in situations where each object needs to\n    be treated differently. It can be used to produce a unique random\n    number for each object, for example. "]}, {"type": "para", "indent": 4, "extent": [3168, 3406], "text": ["This value is also the best way\n    to look up information on an object using the dopfield expression\n    function. This value will be -1 if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [2616, 2623], "text": ["OBJID"]}, {"body": [{"type": "para", "indent": 4, "extent": [3417, 3556], "text": ["This string contains a space separated list of the unique object\n    identifiers for every object being processed by the current node."]}], "type": "dt", "indent": 0, "extent": [3406, 3417], "text": ["ALLOBJIDS"]}, {"body": [{"type": "para", "indent": 4, "extent": [3569, 3687], "text": ["This string contains a space separated list of the names of every\n    object being processed by the current node."]}], "type": "dt", "indent": 0, "extent": [3556, 3569], "text": ["ALLOBJNAMES"]}, {"body": [{"type": "para", "indent": 4, "extent": [3694, 3801], "text": ["This value is the simulation time (see variable ST) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "extent": [3801, 4057], "text": ["Therefore, to check if an object was created\n    on the current timestep, the expression ", {"text": ["$ST == $OBJCT"], "type": "code"}, " should\n    always be used. This value will be zero if the node does not process\n    objects sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [3687, 3694], "text": ["OBJCT"]}, {"body": [{"type": "para", "indent": 4, "extent": [4064, 4172], "text": ["This value is the simulation frame (see variable SF) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "extent": [4172, 4389], "text": ["This value is equivalent to using the\n    dopsttoframe expression on the OBJCT variable. This value will be\n    zero if the node does not process objects sequentially (such as the\n    ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [4057, 4064], "text": ["OBJCF"]}, {"body": [{"type": "para", "indent": 4, "extent": [4398, 4486], "text": ["This is a string value containing the name of the object being\n    processed. "]}, {"type": "para", "indent": 4, "extent": [4486, 4748], "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "]}, {"type": "para", "indent": 4, "extent": [4748, 5194], "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named \"myobject\",\n    specifying ", {"text": ["strcmp($OBJNAME, \"myobject\") == 0"], "type": "code"}, " in the activation field\n    of a DOP will cause that DOP to operate only on those 20 objects. This\n    value will be the empty string if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "extent": [4389, 4398], "text": ["OBJNAME"]}, {"body": [{"type": "para", "indent": 4, "extent": [5202, 5425], "text": ["This is a string value containing the full path of the current DOP\n    Network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP Network that contains the\n    node."]}], "type": "dt", "indent": 0, "extent": [5194, 5202], "text": ["DOPNET"]}], "type": "dt_group", "container": true}, {"body": [{"body": [{"type": "para", "indent": 4, "extent": [5431, 5620], "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"text": ["Position node"], "fullpath": "/nodes/dop/position", "scheme": "Node", "type": "link", "value": "/nodes/dop/position"}, ",\n    you could write the expression:"]}, {"lang": null, "type": "pre", "indent": 4, "extent": [5620, 5650], "text": ["\n    $tx + 0.1\n    "]}, {"type": "para", "indent": 4, "extent": [5650, 5730], "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."]}], "role": "item", "indent": 0, "extent": [5425, 5431], "type": "note"}], "role": "item_group", "container": true, "type": "note_group"}], "indent": 0, "level": 1, "text": "Locals", "role": "section", "extent": [8887, 8895], "container": true, "type": "locals_section", "id": "locals"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [8932, 8962], "text": [{"text": "", "fullpath": "/nodes/dop/conetwistconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/conetwistconrel"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8962, 8997], "text": [{"text": "", "fullpath": "/nodes/sop/connectadjacentpieces", "scheme": "Node", "type": "link", "value": "/nodes/sop/connectadjacentpieces"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8997, 9040], "text": [{"text": "", "fullpath": "/nodes/dop/constraintnetworkrelationship", "scheme": "Node", "type": "link", "value": "/nodes/dop/constraintnetworkrelationship"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9040, 9064], "text": [{"text": "", "fullpath": "/nodes/dop/glueconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/glueconrel"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9064, 9088], "text": [{"text": "", "fullpath": "/nodes/dop/hardconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/hardconrel"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9088, 9114], "text": [{"text": "", "fullpath": "/nodes/dop/sliderconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/sliderconrel"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9114, 9140], "text": [{"text": "", "fullpath": "/nodes/dop/springconrel", "scheme": "Node", "type": "link", "value": "/nodes/dop/springconrel"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [8923, 8932], "container": true, "type": "related_section", "id": "related"}], "title": ["Constraint Network"], "summary": ["Constrains pairs of RBD objects together according to a polygon network."], "attrs": {"version": null, "namespace": null, "internal": "constraintnetwork", "context": "dop", "type": "node", "icon": "DOP/constraintnetwork"}, "included": ["/nodes/dop/standard_constraintnetworkattribs", "/nodes/dop/standard_data_outputs", "/nodes/dop/standard_dataactive_parms", "/nodes/dop/standard_locals"], "type": "root"}